<html>
  <head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
<!--
    ##     ## ######## ##     ## ##
    ##     ##    ##    ###   ### ##
    ##     ##    ##    #### #### ##
    #########    ##    ## ### ## ##
    ##     ##    ##    ##     ## ##
    ##     ##    ##    ##     ## ##
    ##     ##    ##    ##     ## ########
-->
    <div id="maintable">
        <div id="col_roster"><div id="roster"></div></div>
        <div id="col_livestats">
            <div id="mystats">
                <span>
                    <div id="myColor"></div>
                    <span id="myName" class="statsname"></span>
                </span>
                <div id="killsandhs">
                    <div>Kills: <span id="kills">?</span></div>
                    <div>Headshots: <span id="headshots">?</span></div>
                </div>
                <div>Total damage dealt: <span id="damagedealt">?</span></div>
                <div>Max kill distance: <span id="maxkilldist">?</span>m</div>
                <div id="gear">
                    <img class="gearimg" id="img_helmet_me"/>
                    <img class="gearimg" id="img_vest_me"/>
                    <img class="gearimg" id="img_bag_me"/>
                    <img class="gearimg" id="img_ghillie_me"/>
                </div>
                <div id="weapons">
                    <!-- <div id="wpnA"><img class="wpnimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="/></div> -->
                    <!-- <div id="wpnB"><img class="wpnimg" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="/></div> -->
                    <div id="wpnA"><img class="wpnimg"/></div>
                    <div id="wpnB"><img class="wpnimg"/></div>
                </div>
                <div id="inventory"></div>
            </div>
            <!-- <div id="squad_livestats"></div> -->
            <!-- <button onclick="javascript:simButton();">Sim</button> -->
            <!-- <button onclick="javascript:simNewFP();">New Flightpath</button> -->
            <!-- <div><canvas id="heatmapcanvas" width=100 height=100></canvas></div> -->
            <!-- <input type="text" id="divider" value="300"/> -->
            <!-- <input type="text" id="subtract" value="50"/> -->
        </div>
        <div id="col_map" width="10%;">
            <canvas style="border:1px solid #000;" id="mapcanvas"><p>lol i guess you're using a browser from the 70s or something</p></canvas>
        </div>
    </div>
    <script>
/*
     ######   ##        #######  ########     ###    ##        ######
    ##    ##  ##       ##     ## ##     ##   ## ##   ##       ##    ##
    ##        ##       ##     ## ##     ##  ##   ##  ##       ##
    ##   #### ##       ##     ## ########  ##     ## ##        ######
    ##    ##  ##       ##     ## ##     ## ######### ##             ##
    ##    ##  ##       ##     ## ##     ## ##     ## ##       ##    ##
     ######   ########  #######  ########  ##     ## ########  ######
*/

    var minPixelsToAnimate = 1;

    var myName = getUrlPlayerName();
    var curPhase  = "lobby";
    var curMode   = "solo";
    var curMap    = "";
    var curMapSize = 8160;
    var curFlightPath  = undefined;

    var curPosX = 0;
    var curPosY = 0;
    var prevPosX = 0;
    var prevPosY = 0;

    var curPlaneDirection = undefined;
    var curPlanePosX = 0;
    var curPlanePosY = 0;
    var curPlaneSpeed = 0;
    var planeStartX = undefined;
    var planeStartY = undefined;
    var planeStartTime = undefined;

    var curDamageDealt = 0;
    var curKills = 0;
    var curHeadshots = 0;
    var curMaxKillDist = 0;

    var curInvRaw = "";
    var curInv = buildEmptyInventory();

    var rosterEverGot = false;
    var curRoster = [];
    var curAlives = "";

    var curWhite = undefined;
    var curBlue  = undefined;
    var curRed   = undefined;

    var prevWhite = undefined;
    var prevBlue  = undefined;
    var prevRed   = undefined;

    var calcFlightPath = undefined;
    var calcLandingLines = undefined;
    var prevCalcFlightPath = undefined;
    var prevCalcLandingLines = undefined;
    var animateFlightPath = false;

    var curTeamData = [];
    var prevTeamLocs = [];

    var curSquad     = [];
    var prevSquad    = [];
    var curSquadInfo = [];

    var blueZoneColor = '#00F4';
    var redZoneColor  = '#F004';

    var curViewBox = OUTSIDEVIEWBOX();
    var renderViewBox = curViewBox;
    var prevViewBox = curViewBox;
    
    // simulation data
    var sims = [];
    var curEdge = Array(64).fill(0);
    var curEdgeMax = 0;
    var debug_drawSims = false;
    var debug_runsim = true;

    var stillDeadTime = 60;                    // how many seconds a player stays still before assumed dead.
    var stillTime = [0,0,0,0,0];               // how long each player has remained still (in seconds-ish)

    var playerColors = [                       // the colors used for each player.
        "#ffea00", // yellow (you)
        "#ff8000", // orange
        "#00e673", // green
        "#1a8cff", // blue
        "fuchsia", "teal", "red", "aqua" // just in case
    ];


/*
  ######  #### ##     ##  ######
 ##    ##  ##  ###   ### ##    ##
 ##        ##  #### #### ##
  ######   ##  ## ### ##  ######
       ##  ##  ##     ##       ##
 ##    ##  ##  ##     ## ##    ##
  ######  #### ##     ##  ######
*/

var divider = 300;
var subtract = 50;
function initialiseHeatmapSims() {
    if (myName==="MrWraith" || myName==="Forqoten" || myName==="MrWraith2")
        debug_drawSims = true;

    // empty sims list
    sims = [];
    simsNeedBuilding = false;

    // divider = parseInt($("#divider").val());
    // subtract = parseInt($("#subtract").val());

    // load the heatmap with flightpath data
    var d = getImgData(img_heat,100);
    // // draw the heatmap, just for debugging
    // var tcanv = $("#heatmapcanvas")[0];
    // tcanv.width = 100;
    // tcanv.height = 100;
    // var tctx = tcanv.getContext("2d");
    // tctx.putImageData(d,0,0);
    for (var x=0; x<100; x+=1) {
        for (var y=0; y<100; y+=1) {
            // the index of this pixel in the data
            var di = (y * 100 + x) * 4;
            var heat = d.data[di];
            heatPoint(x,y,heat);
        }
    }
}

// given a heat value (usually 0-255), return a boolean
// deciding whether to place a sim at this point.
function maybePointForHeat(x) {
    var q = ((x-subtract)/divider); // formula
    return Math.random()<q;
}

// perhaps place a sim at this point on the map, depending
// on the heat here
function heatPoint(x,y,heat) {
    var mx = (x+1)*curMapSize/100;
    var my = (y+1)*curMapSize/100;
    if (maybePointForHeat(heat))
        sims.push([mx,my]);
}


// get the image data from the given image,
// but first draw the flightmap on top of it
function getImgData(i, sz) {
    var tempCanvas = document.createElement('canvas');
    var tempContext = tempCanvas.getContext('2d');
    tempCanvas.width = sz;
    tempCanvas.height = sz;
    tempContext.drawImage(i, 0, 0, sz, sz);
    drawFlightPathOnHeatMap(tempContext,100);
    return tempContext.getImageData(0, 0, sz, sz);
}

// move all simulated players directly to the white circle,
// and recalculate edge densities.
function moveSimsToWhite() {
    if (!curWhite) return;
    // reset the edge
    curEdge = Array(64).fill(0);
    curEdgeMax = 0;

    var white = JSON.parse(curWhite);
    var thetas = [];

    // "bring in" sims that are X radius from the center.
    // 1.0 = only strictly outside.
    var collectBound = 0.9;

    var collectRad = (collectBound * white.radius);
    var collectSq = collectRad*collectRad;
    // remove all sims outside the new white circle
    sims = sims.filter(function(xy){
        var yDiff = xy[1]-white.y;
        var xDiff = xy[0]-white.x;
        var theta  = Math.atan2(yDiff,xDiff);
        var distSq = (xDiff*xDiff) + (yDiff*yDiff);
        if (distSq < collectSq) {
            return true;
        } else {
            thetas.push(theta);
            return false;
        }
    });

    // add all sims back, on the edge of the circle,
    // and calculate edge density
    for (var i=0; i<thetas.length; i++) {
        var theta = thetas[i];
        if (theta<0) theta = theta + 2*Math.PI;
        var x = white.x + white.radius*Math.cos(theta);
        var y = white.y + white.radius*Math.sin(theta);
        sims.push([x,y]);
        var ind = Math.round(theta*10)%64;

        // add densities to the edge.
        // right now we add some smoothing
        curEdge[(ind-1)%64]++;
        curEdge[ind]+=2;
        curEdge[(ind+1)%64]++;

        // keep track of (roughly) the maximum edge density
        if (curEdge[ind] > curEdgeMax) {
            curEdgeMax = curEdge[ind];
        }
    }
}

// draw the whole white circle edge (made of arcs)
function drawEdge(percent) {
    if (!curWhite) return;
    var white = JSON.parse(curWhite);
    var x = white.x;
    var y = white.y;
    var rad = white.radius;

    if (notBlank(percent) && prevWhite) {
        var oldWhite = JSON.parse(prevWhite);
        x = getBetween(oldWhite.x, white.x, percent);
        y = getBetween(oldWhite.y, white.y, percent);
        rad = getBetween(oldWhite.radius, white.radius, percent);
    }
    
    var [cx, cy, z] = orientForCamera(x, y);
    rad = z * rad;

    ctx.lineCap = "butt";
    for (var i=0; i<curEdge.length; i++) {
        if (curEdge[i]>0) {
            var theta = i/10;
            var val = curEdge[i];
            drawEdgeArc(cx,cy,rad,theta,val);
        }
    }
}

// turn a value (0.0-1.0) into a color for the edge
function heatMapColorforValue(value){
  var h = (1.0 - value) * 25;
  var p = Math.round(80-value * 50);
  return "hsla(" + h + ", 100%, "+p+"%,0.7)";
}

// normalise some edge density into a value 0.0-1.0.
function edgeNormalise(x) {
    x = x / curEdgeMax;
    if (x > 1) return 1;
    return x;
}

function drawEdgeArc(cx, cy, rad, theta, sz) {
    ctx.beginPath();
    ctx.arc(cx, cy, rad, theta, theta+0.1);
    var edgeNorm = edgeNormalise(sz);
    ctx.lineWidth = 1+edgeNorm*5;
    ctx.strokeStyle = heatMapColorforValue(edgeNorm);
    ctx.stroke();
    ctx.closePath();
}

function drawFlightPathOnHeatMap(tCtx, sz) {
    tCtx.globalCompositeOperation = 'color-dodge';
    tCtx.lineCap = 'square';
    var startx = calcFlightPath.start.x * (sz/curMapSize);
    var starty = calcFlightPath.start.y * (sz/curMapSize);
    var endx   = calcFlightPath.end.x   * (sz/curMapSize);
    var endy   = calcFlightPath.end.y   * (sz/curMapSize);
    var innerWidth = 250000/curMapSize; // inner dotted is 280000/curMapSize
    var outerWidth = 500000/curMapSize; // outer dotted is 400000/curMapSize
    tCtx.beginPath();
    tCtx.setLineDash([]);
    tCtx.moveTo(
        startx,
        starty
    );
    tCtx.lineTo(
        endx,
        endy
    );
    // tCtx.strokeStyle = "#333";
    tCtx.lineWidth = innerWidth;
    tCtx.strokeStyle = "#555";
    // tCtx.strokeStyle = "#FFF";
    tCtx.stroke();
    tCtx.lineWidth = outerWidth;
    tCtx.strokeStyle = "#222";
    tCtx.stroke();
    tCtx.closePath();
    tCtx.globalCompositeOperation = 'source-over';
}





// the below are for drawing the simulated players. not usually used,
// but essential for debugging the player simulation.
function drawSims() {
    for (var i=0; i<sims.length; i++) {
        var x = sims[i][0];
        var y = sims[i][1];
        drawSimAt(x,y);
    }
}

function drawSimAt(x, y) {
    [newX, newY, z] = orientForCamera(x, y);
    drawSim(newX, newY);
}

function drawSim(x, y) {
    ctx.fillStyle = '#0F05';
    var simRad = 2;
    ctx.fillRect(x-simRad,y-simRad,simRad*2,simRad*2);
}


// the below are for the debug buttons when developing the
// player simulation
function simButton() {
    initialiseHeatmapSims();
}

var overridingFP = false;
function simNewFP() {
    overridingFP = true;
    calcFlightPath.start.x = Math.random()*curMapSize;
    calcFlightPath.end.x = Math.random()*curMapSize;
    calcFlightPath.start.y = 0;
    calcFlightPath.end.y = curMapSize;
    recalculateFlightPath(calcFlightPath);
    initialiseHeatmapSims();
}








/*
    ########  ########     ###    ##      ## #### ##    ##  ######
    ##     ## ##     ##   ## ##   ##  ##  ##  ##  ###   ## ##    ##
    ##     ## ##     ##  ##   ##  ##  ##  ##  ##  ####  ## ##
    ##     ## ########  ##     ## ##  ##  ##  ##  ## ## ## ##   ####
    ##     ## ##   ##   ######### ##  ##  ##  ##  ##  #### ##    ##
    ##     ## ##    ##  ##     ## ##  ##  ##  ##  ##   ### ##    ##
    ########  ##     ## ##     ##  ###  ###  #### ##    ##  ######
*/

    var canvas = document.getElementsByTagName('canvas')[0];
    // var canvas = document.getElementsByTagName('canvas')[1];
    canvas.width  = Math.min(window.innerWidth, window.innerHeight)-20;
    canvas.height = Math.min(window.innerWidth, window.innerHeight)-20;
    var ctx = canvas.getContext("2d");

    // the heatmap image for the current map
    var img_heat_loaded = false;
    var img_heat_onload = function() {
        img_heat_loaded = true;
    }
    var img_heat = new Image();
    img_heat.onload = img_heat_onload;

    // the plane image
    var img_aircraft  = new Image();
    img_aircraft.src = "img/map-aircraft-150.png";

    // the main map image
    var img         = new Image();
    var img_loader  = new Image();
    var imageLoaded = false;
    var img_onload = function() {
        imageLoaded = true;
        initiateRedraw();
    }
    var img_loader_onload = function() {
        // this is used for loading in higher-res images when zooming in

        // replace the map store with the newly loaded image.
        img = img_loader;
        img_loader = new Image();

        // set appropriate onload behaviour for both images.
        img.onload = img_onload;
        img_loader.onload = img_loader_onload;

        console.log("loaded in new image", img.width);
    }

    img_loader.onload = img_loader_onload;
    img.onload = img_onload;


    function initiateRedraw() {
        if (!imageLoaded) return;
        if (shouldAnimate()) {
            // animate through redrawing
            $({foo: 0}).animate({foo: 1}, {
                duration: 1000,
                easing: 'linear',
                queue: false,
                step: function(val) {
                    redrawEverything(val);
                }
            });
        } else {
            // just redraw once
            redrawEverything();
        }
    }

    var viewbox = {
        top: 0,
        left: 0,
        bottom: 1000,
        right: 1000
    };
    function ZEROVIEWBOX(x, y) {
        return {
            top:    y,
            left:   x,
            bottom: y,
            right:  x
        };        
    }
    function OUTSIDEVIEWBOX() {
        return {
            top:    0,
            left:   0,
            bottom: curMapSize,
            right:  curMapSize
        };
    }

    function expandAndSquare(box, padding) {
        var cx  = (box.left + box.right) / 2;
        var cy  = (box.top + box.bottom) / 2;
        var wid = box.right - box.left;
        var hgt = box.bottom - box.top;

        var newWid = Math.max(wid,hgt) * padding;
        var newWidHalf = newWid/2;

        return {
            top:    cy - newWidHalf,
            left:   cx - newWidHalf,
            bottom: cy + newWidHalf,
            right:  cx + newWidHalf,
        };
    }

    function pushInside(box) {
        if (box.top < 0) {
            box.bottom += -box.top; // move bottom DOWN
            box.top = 0;
        }
        if (box.left < 0) {
            box.right += -box.left; // move right RIGHT
            box.left = 0;
        }
        if (box.bottom > curMapSize) {
            box.top -= (box.bottom - curMapSize); // move top UP
            box.bottom = curMapSize;
        }
        if (box.right > curMapSize) {
            box.left -= (box.right - curMapSize); // move left LEFT
            box.right = curMapSize;
        }
        return box;
    }

    function intersectEdges(box) {
        var changed = false;
        if (box.top < 0) {
            box.top = 0;
            changed = true;
        }
        if (box.left < 0) {
            box.left = 0;
            changed = true;
        }
        if (box.bottom > curMapSize) {
            box.bottom = curMapSize;
            changed = true;
        }
        if (box.right > curMapSize) {
            box.right = curMapSize;
            changed = true;
        }
        return changed;
    }

    var viewbox_expand_amount = 1.15;
    function CALCULATEVIEWBOX() {
        if (curPhase==="lobby"
         || curPhase==="loading_screen"
         || curPhase==="airfield")
        //  || curLocs.length===0)
            return OUTSIDEVIEWBOX();

        var box = null;

        // start with some player position
        if (!isDead()) {
            box = ZEROVIEWBOX(curPosX, curPosY);
        } else {
            for (var mateName in curTeamData) {
                var mate = curTeamData[mateName]
                if (mate.alive===true) {
                    box = ZEROVIEWBOX(mate.x, mate.y);
                    break;
                }
            }
            // for (var i=0; i<curLocs.length; i++) {
            //     if (curLocs[i].dead === false) {
            //         box = ZEROVIEWBOX(curLocs[i].x, curLocs[i].y);
            //         break;
            //     }
            // }
        }
        if (box===null) return OUTSIDEVIEWBOX();
        
        // this will expand the box to contain any given point
        var includePoint = function(x, y) {
            box.top    = Math.min(box.top,  y);
            box.left   = Math.min(box.left, x);
            box.bottom = Math.max(box.bottom, y);
            box.right  = Math.max(box.right, x);
        };

        // this will expand the box to contain any given zone
        var includeZone = function(zonetext) {
            if (isBlank(zonetext)) return;
            var zone = JSON.parse(zonetext);
            includePoint(zone.x - zone.radius, zone.y - zone.radius);
            includePoint(zone.x + zone.radius, zone.y + zone.radius);
        }

        // make sure that all player positions are in the box
        if (!isDead())
            includePoint(curPosX, curPosY);
        for (var mateName in curTeamData) {
            var mate = curTeamData[mateName];
            if (mate.alive)
                includePoint(mate.x, mate.y);
        }
        // for (var i=0; i<curLocs.length; i++)
        //     if (!curLocs[i].dead)
        //         includePoint(curLocs[i].x, curLocs[i].y);

        // make sure that zones are in the box
        includeZone(curWhite);
        includeZone(curBlue);

        // at this point, the box exactly bounds the players and the outer zone
        // drawBox(box, '#F00');

        // if it's too big, just return the outer box
        if ((box.right - box.left) >= curMapSize) return OUTSIDEVIEWBOX();
        if ((box.bottom - box.top) >= curMapSize) return OUTSIDEVIEWBOX();

        // if it's zero-sized, just return the outer box
        if (box.right == box.left) return OUTSIDEVIEWBOX();
        if (box.top == box.bottom) return OUTSIDEVIEWBOX();

        // 'square' the box and expand it to include padding
        box = expandAndSquare(box, viewbox_expand_amount);
        // drawBox(box, '#FF0');

        // 'intersect' the box with the edges, so there is no overlap
        if (intersectEdges(box)) {
            // intersecting changed the box. re-square it and make sure it's
            // still inside the bounds.

            // re-square (but don't expand)
            box = expandAndSquare(box, 1);

            // push the box inside the bounds
            box = pushInside(box);
        }

        // all done
        return box;
    }

    function defaultViewBox() {
        curViewBox    = OUTSIDEVIEWBOX();
        renderViewBox = OUTSIDEVIEWBOX();
        prevViewBox   = OUTSIDEVIEWBOX();
    }

    function recalculateViewBox() {
        // save the previous view box (for animations)
        prevViewBox = curViewBox;
        if (isBlank(prevViewBox)) prevViewBox = OUTSIDEVIEWBOX();
        
        // recalculate curViewBox
        curViewBox = CALCULATEVIEWBOX();
    }

    function diffBox(boxA, boxB) {
        if (isBlank(boxA)) return true;
        if (isBlank(boxB)) return true;
        if (boxA.top    !== boxB.top)    return true;
        if (boxA.left   !== boxB.left)   return true;
        if (boxA.bottom !== boxB.bottom) return true;
        if (boxA.right  !== boxB.right)  return true;
        return false;
    }

    function betweenBox(boxA, boxB, percent) {
        return {
            top:    getBetween(boxA.top,    boxB.top,    percent),
            left:   getBetween(boxA.left,   boxB.left,   percent),
            bottom: getBetween(boxA.bottom, boxB.bottom, percent),
            right:  getBetween(boxA.right,  boxB.right,  percent)
        };
    }

    function calculateRenderViewBox(percent) {
        renderViewBox = betweenBox(prevViewBox, curViewBox, percent);
    }

    function redrawEverything(percent) {

        // figure out the temporary view box for this frame
        if (notBlank(percent)) calculateRenderViewBox(percent);
        else renderViewBox = curViewBox;
        
        // clear the canvas with the map image
        // (animation here is organised by the view box)
        drawMap();

        // (perhaps) draw the sims
        if (debug_drawSims) drawSims();

        // draw flight paths (if appropriate)
        drawFlightPaths(percent);

        // draw zones
        drawZones(percent);

        // draw zone edge
        if (debug_runsim) drawEdge(percent);
        
        // write phase and mode
        drawPhase();
        drawMode();

        // draw locations
        drawLocations(percent);
    }

    function orientForCamera(x, y) {
        var viewBox = renderViewBox;
        var z = canvas.scrollWidth / (viewBox.right - viewBox.left);
        var newX = z*(x-viewBox.left);
        var newY = z*(y-viewBox.top);
        return [newX, newY, z];
    }

    function drawMap() {
        var [sx, sy] = orientForCamera(0,0);
        var zz = curMapSize / (renderViewBox.right - renderViewBox.left);
        var renderMapSize = zz*canvas.scrollWidth;
        // notifyRenderMapSize(renderMapSize);
        ctx.drawImage(img, sx, sy, renderMapSize, renderMapSize);
    }

    var currentRenderMapSize = undefined;
    function updateRenderMapSize() {
        var size = canvas.scrollWidth * curMapSize / (renderViewBox.right - renderViewBox.left);
        if (isBlank(currentRenderMapSize)) {
            currentRenderMapSize = size;
            return;
        }
        var sizeChangeTrigger = canvas.scrollWidth * 0.25;
        if (Math.abs(currentRenderMapSize - size) > sizeChangeTrigger) {
            var roundAmount = 200;
            var grabSize = roundAmount*Math.round(size/roundAmount); // round it, so caching works a lot better
            img_loader.src = "maps/getmap.php?map="+curMap+"&size="+grabSize;
            currentRenderMapSize = size;
        }
    }

    function drawPhase() {
        ctx.textAlign = "left";
        ctx.font = "20px Century Gothic Regular"
        ctx.fillStyle = 'white';
        ctx.fillText(nicePhase(), 10, canvas.height-15);
    }

    function drawMode() {
        if (!drawModeForPhase(curPhase)) return;
        ctx.textAlign = "right";
        ctx.font = "20px Century Gothic Regular"
        ctx.fillStyle = 'white';
        ctx.fillText(niceMode(), canvas.width - 10, canvas.height-15);
    }

    function drawLocations(percent) {
        if (drawLocationsForPhase(curPhase)) {
            if (curPhase !== "aircraft" && curPlanePosX!==0) {
                // draw the plane before the players, and animate it
                drawAutoPlane();
            }

            for (var mateName in curTeamData) {
                var mate = curTeamData[mateName];
                if (prevTeamLocs[mateName]) {
                    var px = mate.x;
                    var py = mate.y;
                    if (notBlank(percent)) {
                        // maybe we are drawing a between frame
                        px = getBetween(prevTeamLocs[mateName].x, px, percent);
                        py = getBetween(prevTeamLocs[mateName].y, py, percent);
                    }
                    drawPersonAt(px, py, mateName, !mate.alive);
                }
            }
            var px = curPosX;
            var py = curPosY;
            if (notBlank(percent) && (px!==0 || py!==0)) {
                px = getBetween(prevPosX, px, percent);
                py = getBetween(prevPosY, py, percent);
            }
            if (curPhase==="aircraft") {
                curPlanePosX = px;
                curPlanePosY = py;
                drawPlane();
            } else {
                drawPersonAt(px, py, myName, isDead());
            }



            // for (var i=curLocs.length-1; i>=0; i--) {
            //     if (prevLocs[i] && curLocs[i]) {
            //         var pname = curLocs[i].name;
            //         var px = curLocs[i].x;
            //         var py = curLocs[i].y;
            //         if (notBlank(percent)) {
            //             // maybe we are drawing a between frame
            //             px = getBetween(prevLocs[i].x, curLocs[i].x, percent);
            //             py = getBetween(prevLocs[i].y, curLocs[i].y, percent);
            //         }
            //         var dead = curLocs[i].dead; // || stillTime[i]>(stillDeadTime);
        
            //         drawPersonAt(px, py, i, dead);

            //         if (i===0 && curPhase==="aircraft") {
            //             // draw the plane after the players, on top of yourself
            //             curPlanePosX = px;
            //             curPlanePosY = py;
            //             drawPlane();
            //         }
            //     }
            // }
        }
    }

    var origPlaneSpeed = 0;
    function prepareAutoPlane() {
        planeStartX = curPlanePosX;
        planeStartY = curPlanePosY;
        var timeDiff = fpEndTime - fpStartTime; // in ms
        var locDiff  = Math.sqrt( Math.pow((fpEndPosX-fpStartPosX), 2) + Math.pow((fpEndPosY-fpEndPosY), 2) );
        curPlaneSpeed = locDiff / timeDiff;
        origPlaneSpeed = curPlaneSpeed;
        planeStartTime = new Date();
    }

    function drawAutoPlane() {
        if (planeStartTime===undefined) planeStartTime = new Date();
        var timePassed = ((new Date()) - planeStartTime)
        curPlanePosX = planeStartX + timePassed*curPlaneSpeed*Math.cos(curPlaneDirection);
        curPlanePosY = planeStartY + timePassed*curPlaneSpeed*Math.sin(curPlaneDirection);
        // accelarate the plane
        curPlaneSpeed = origPlaneSpeed + (timePassed * 0.00005);
        if (curPlanePosX < -300
         || curPlanePosY < -300
         || curPlanePosX > curMapSize + 300
         || curPlanePosY > curMapSize + 300) {
            curPlanePosX = 0;
            curPlanePosY = 0;
        } else {
            drawPlane();
        }
    }

    function drawPlane() {
        [newX, newY, z] = orientForCamera(curPlanePosX, curPlanePosY);
        ctx.translate(newX, newY);
        ctx.rotate(curPlaneDirection);
        ctx.drawImage(img_aircraft, -54, -75, 108, 150);
        ctx.rotate(-curPlaneDirection);
        ctx.translate(-newX, -newY);
    }

    function drawZones(percent) {
        if (drawZonesForPhase(curPhase)) {
            if (isBlank(percent))
                drawZonesHere();
            else
                drawZonesBetween(percent);
        }
    }

    // draw zone between the previous and current locations
    function drawZonesBetween(percent) {
        // BLUE ZONE
        if (curBlue && prevBlue) {
            // we are animating between zones
            var blue = JSON.parse(curBlue);
            var pblue = JSON.parse(prevBlue);
            drawMapCircleOutside(
                getBetween(pblue.x, blue.x, percent),
                getBetween(pblue.y, blue.y, percent),
                getBetween(pblue.radius, blue.radius, percent),
                blueZoneColor
            );
        }

        // WHITE ZONE
        if (curWhite && prevWhite) {
            // we are animating between zones
            var white = JSON.parse(curWhite);
            var pwhite = JSON.parse(prevWhite);
            drawMapCircleOutline(
                getBetween(pwhite.x, white.x, percent),
                getBetween(pwhite.y, white.y, percent),
                getBetween(pwhite.radius, white.radius, percent),
                '#FFF'
            );
        }

        // RED ZONE (don't animate)
        if (curRed) {
            var red = JSON.parse(curRed);
            drawMapCircleInside(red.x, red.y, red.radius, redZoneColor);
        }
    }

    // draw zones
    function drawZonesHere() {
        if (notBlank(curBlue)) {
            var blue = JSON.parse(curBlue);
            drawMapCircleOutside(blue.x, blue.y, blue.radius, blueZoneColor);
        }
        if (notBlank(curWhite)) {
            var white = JSON.parse(curWhite);
            drawMapCircleOutline(white.x, white.y, white.radius, '#FFF');
            // drawEdge(white,curEdge);
        }
        if (notBlank(curRed)) {
            var red = JSON.parse(curRed);
            drawMapCircleInside(red.x, red.y, red.radius, redZoneColor);
        }
    }

    // decide whether we should just draw the current information, or if we should animate
    // between the old and the new information
    function shouldAnimate() {

        // for (var i=0; i<prevLocs.length && i<curLocs.length; i++) {
        //     var diff = Math.abs(prevLocs[i].x-curLocs[i].x)
        //              + Math.abs(prevLocs[i].y-curLocs[i].y);
        //     if (diff===0){
        //         stillTime[i]++;
        //     } else {
        //         stillTime[i]=0;
        //         if (diff > maxChg)
        //             maxChg = diff;
        //     }
        // }

        // animate if flight paths should animate
        if (animateFlightPath) return true;

        // animate if we are currently animating the plane
        if (planeStartTime !== undefined && curPlanePosX!==0) return true;

        // animate if the zones have moved
        if (notBlank(curWhite) && notBlank(prevWhite) && prevWhite!==curWhite) return true;
        if (notBlank(curBlue)  && notBlank(prevBlue)  && prevBlue !==curBlue)  return true;

        // get the maximum change in in-game measurements
        // also record how long each player has been still for
        var maxChg = Math.abs(curPosX-prevPosX) + Math.abs(curPosY-prevPosY);
        for (var mateName in curTeamData) {
            var mate = curTeamData[mateName];
            if (prevTeamLocs[mate.name]) {
                var diff = Math.abs(mate.x-prevTeamLocs[mateName].x)
                         + Math.abs(mate.y-prevTeamLocs[mateName].y);
                if (diff > maxChg)
                    maxChg = diff;
            }
        }

        // get that measurement in on-screen distance (pixels)
        var [_, _, z] = orientForCamera(0, 0);
        var maxChgPx = z*maxChg;
        return (maxChgPx > minPixelsToAnimate);
    }


    function drawMapCircleOutline(x, y, r, color) {
        var [newX, newY, z] = orientForCamera(x, y);
        drawCircleOutline(newX, newY, r*z, color);
    }

    function drawMapCircleOutside(x, y, r, color) {
        var [newX, newY, z] = orientForCamera(x, y);
        drawCircleOutside(newX, newY, r*z, color);
    }

    function drawMapCircleInside(x, y, r, color) {
        var [newX, newY, z] = orientForCamera(x, y);
        drawCircleInside(newX, newY, r*z, color);
    }

    function flightPathBetween(fpA, fpB, percent) {
        return {
            start: {
                x: getBetween(fpA.start.x, fpB.start.x, percent),
                y: getBetween(fpA.start.y, fpB.start.y, percent)
            },
            end: {
                x: getBetween(fpA.end.x, fpB.end.x, percent),
                y: getBetween(fpA.end.y, fpB.end.y, percent)
            }
        };
    }

    function drawFlightPaths(percent) {
        var animating = animateFlightPath && notBlank(percent);
        if (calcFlightPath && drawFlightPathForPhase(curPhase)) {
            if (animating) drawSolidLine(flightPathBetween(prevCalcFlightPath, calcFlightPath, percent));
            else drawSolidLine(calcFlightPath);
        }
        if (calcLandingLines && drawLandingLinesForPhase(curPhase)) {
            for (var i=0; i<calcLandingLines.length; i++) {
                if (animating) drawDashedLine(flightPathBetween(prevCalcLandingLines[i], calcLandingLines[i], percent));
                else drawDashedLine(calcLandingLines[i]);
            }
        }
    }

    function drawMapLoading() {
        ctx.fillStyle = "#FFF";
        ctx.fillRect(0, 0, canvas.scrollWidth, canvas.scrollHeight);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle"; 
        ctx.font = "" + Math.round(canvas.scrollWidth/30) + "px Century Gothic Regular"
        ctx.fillStyle = "#000";
        ctx.fillText("Loading map of "+curMap+"...", canvas.scrollWidth/2, canvas.scrollHeight/2);
    }

    function drawNoInfo() {
        var noInfoText1="No player info found.";
        var noInfoText2="Once you are in the aircraft, this area will update.";

        ctx.fillStyle = "#FFF";
        ctx.fillRect(0, 0, canvas.scrollWidth, canvas.scrollHeight);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle"; 
        ctx.font = "" + Math.round(canvas.scrollWidth/40) + "px Century Gothic Regular"
        ctx.fillStyle = "#000";
        ctx.fillText(noInfoText1, canvas.scrollWidth/2, canvas.scrollHeight/2-15);
        ctx.fillText(noInfoText2, canvas.scrollWidth/2, canvas.scrollHeight/2+15);
    }

    var colors = [];
    var colorNum = 1;
    function colorForName(name) {
        if (colors[name]) return colors[name];
        if (name===myName) {
            colors[myName] = playerColors[0];
        } else {
            colors[name] = playerColors[colorNum%8];
            colorNum += 1;
        }
        return colors[name];
    }

    function drawPersonAt(x, y, name, dead) {
        [newX, newY, z] = orientForCamera(x, y);
        var clr = colorForName(name);
        if (dead)
            drawDead(newX, newY, clr);
        else
            drawCircle(newX, newY, clr);
    }

    // function drawMeAt(x, y) {
    //     [newX, newY, z] = orientForCamera(x, y);
    //     // x = map_to_canvas(x);
    //     // y = map_to_canvas(y);
    //     drawCircle(newX, newY, 'yellow');
    // }

    // function drawBuddyAt(x, y) {
    //     [newX, newY, z] = orientForCamera(x, y);
    //     // x = map_to_canvas(x);
    //     // y = map_to_canvas(y);
    //     drawCircle(newX, newY, 'orange');
    // }


    function drawDead(x, y, clr) {
        var r = 5;

        ctx.beginPath();
        ctx.moveTo(x-r, y-r);
        ctx.lineTo(x+r, y+r);
        ctx.moveTo(x+r, y-r);
        ctx.lineTo(x-r, y+r);
        ctx.lineCap = "round";

        ctx.strokeStyle = clr; // color of the 'outline'
        ctx.lineWidth = 5;
        ctx.stroke();

        ctx.lineWidth = 3;
        ctx.strokeStyle = 'red'; // color of the 'X'
        ctx.stroke();
        ctx.closePath();
    }

    function drawCircle(x, y, color) {
        var centerX = x;
        var centerY = y;
        var radius = 5;

        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.strokeStyle = '#000';
        ctx.fill();
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.closePath();
    }

    function drawCircleOutline(x, y, rad, color) {
        ctx.beginPath();
        ctx.arc(x, y, rad, 0, 2 * Math.PI);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.closePath();
    }

    function drawCircleInside(x, y, rad, color) {
        ctx.beginPath();
        ctx.arc(x, y, rad, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.closePath();
    }

    function drawCircleOutside(x, y, rad, color) {
        ctx.beginPath();
        ctx.rect(0, 0, canvas.scrollWidth, canvas.scrollHeight);
        ctx.arc(x, y, rad, 0, 2 * Math.PI, true);
        ctx.fillStyle = color;
        ctx.fill("evenodd");
        ctx.closePath();
    }

    function drawSolidLine(path) {
        var [startx, starty, _] = orientForCamera(path.start.x, path.start.y);
        var [endx,   endy,   _] = orientForCamera(path.end.x,   path.end.y);
        ctx.beginPath();
        ctx.setLineDash([]);
            ctx.moveTo(
                startx,
                starty
            );
            ctx.lineTo(
                endx,
                endy
            );
        ctx.strokeStyle = "#FFF";
        ctx.lineWidth = 1.1;
        ctx.stroke();
        ctx.closePath();
    }

    function drawDashedLine(path) {
        var [startx, starty, _] = orientForCamera(path.start.x, path.start.y);
        var [endx,   endy,   _] = orientForCamera(path.end.x,   path.end.y);
        ctx.beginPath();
        ctx.setLineDash([5,5]);
            ctx.moveTo(
                startx,
                starty
            );
            ctx.lineTo(
                endx,
                endy
            );
        ctx.strokeStyle = "#FFF";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();
    }





/*
      ######   #######  ##     ##    ###    ########   ######
     ##    ## ##     ## ##     ##   ## ##   ##     ## ##    ##
     ##       ##     ## ##     ##  ##   ##  ##     ## ##
      ######  ##     ## ##     ## ##     ## ##     ##  ######
           ## ##  ## ## ##     ## ######### ##     ##       ##
     ##    ## ##    ##  ##     ## ##     ## ##     ## ##    ##
      ######   ##### ##  #######  ##     ## ########   ######
*/

    function alphasort(str1, str2) {
        return str1.toLowerCase().localeCompare(str2.toLowerCase());
    }

    function updateSquad(squad) {
        // console.log("updating squad");
        squad.sort(alphasort);
        prevSquad = curSquad;
        curSquad = squad;
        curSquadInfo = [];
        emptySquadmateDisplay();
        for (var i=0; i<squad.length; i++) {
            buildSquadmateDisplay(squad[i], playerColors[i+1]);
        }
    }

    function updateSquadInfo(squadinfo) {
        for (var i=0; i<squadinfo.length; i++) {
            teammate = squadinfo[i];
            name = teammate.teammate;

            // make sure there's an entry for this teammate
            if (!(curSquadInfo[name]))
                curSquadInfo[name] = {};

            // update each of their stats
            if (teammate.kills !== curSquadInfo[name].kills) {
                curSquadInfo[name].kills = teammate.kills;
                $("#stats_"+name).find("#kills").text(teammate.kills);
            }
            if (teammate.headshots !== curSquadInfo[name].headshots) {
                curSquadInfo[name].headshots = teammate.headshots;
                $("#stats_"+name).find("#headshots").text(teammate.headshots);
            }
            if (teammate.maxkilldist !== curSquadInfo[name].maxkilldist) {
                curSquadInfo[name].maxkilldist = teammate.maxkilldist;
                $("#stats_"+name).find("#maxkilldist").text(Math.round(teammate.maxkilldist)/100);
            }
            if (teammate.damagedealt !== curSquadInfo[name].damagedealt) {
                curSquadInfo[name].damagedealt = teammate.damagedealt;
                $("#stats_"+name).find("#damagedealt").text(Math.round(teammate.damagedealt));
            }
            if (teammate.inv !== curSquadInfo[name].inv) {
                curSquadInfo[name].inv = teammate.inv;
                updateTeammateInventory(name, teammate.inv);
            }
        }
    }

    function emptySquadmateDisplay() {
        $("#mystats").nextAll().remove();
    }

    var squadmatesHaveContent = [];

    function showSquadmateContent(name) {
        if (squadmatesHaveContent[name]) return;
        squadmatesHaveContent[name] = true;
        $("#col_livestate").find(""); // meow
    }

    function buildSquadmateDisplay(name, clr) {
        squadmatesHaveContent[name] = false;
        cont = $("#col_livestats");
        var statsHTML = '<div class="squadstatswrapper" id="stats_'+name+'">'
        + '    <span><div id="myColor" style="background-color:'+clr+'"></div>'
        + '      <span class="statsname">'+name+'</span></span>'
        + '    <div id="playercontent">'
        + '    <div id="killsandhs">'
        + '        <div>Kills: <span id="kills">?</span></div>'
        + '        <div>Headshots: <span id="headshots">?</span></div>'
        + '    </div>'
        + '    <div>Total damage dealt: <span id="damagedealt">?</span></div>'
        + '    <div>Max kill distance: <span id="maxkilldist">?</span>m</div>'
        + '    <div id="gear">'
        + '        <img class="gearimg" id="img_helmet"/>'
        + '        <img class="gearimg" id="img_vest"/>'
        + '        <img class="gearimg" id="img_bag"/>'
        + '        <img class="gearimg" id="img_ghillie"/>'
        + '    </div>'
        + '    <div id="weapons">'
        + '        <div id="wpnA"><img class="wpnimg"/></div>'
        + '        <div id="wpnB"><img class="wpnimg"/></div>'
        // + '        <div id="wpnA"><img class="wpnimg" src="'+blank_image_base64+'"/></div>'
        // + '        <div id="wpnB"><img class="wpnimg" src="'+blank_image_base64+'"/></div>'
        + '    </div>'
        + '    <div id="inventory"></div>'
        + '    </div>'
        + '</div>'
        cont.append(statsHTML);
    }

    function diffSquad(squadA, squadB) {
        if (squadA.length !== squadB.length) return true;
        for (var i=0; i<squadA.length; i++)
            if (squadA[i] !== squadB[i])
                return true;
        return false;
    }


/*
    ########  ##     ##    ###     ######  ########
    ##     ## ##     ##   ## ##   ##    ## ##
    ##     ## ##     ##  ##   ##  ##       ##
    ########  ######### ##     ##  ######  ######
    ##        ##     ## #########       ## ##
    ##        ##     ## ##     ## ##    ## ##
    ##        ##     ## ##     ##  ######  ########
*/
    
    var rosterInterval = undefined;
    var rosterWait = 5000;
    var simsNeedBuilding = false;
    function updatePhase(phase) {
        if (isBlank(phase)) return;
        console.log("Changing phase to " + phase);
        curPhase = phase;
        if (curPhase === "lobby") {
            // empty the roster
            onLobby();
        }
        if (curPhase === "airfield") {
            // poll for the roster every 5 seconds during pregame
            clearInterval(rosterInterval);
            rosterInterval = setInterval(getRoster, 5000);
            getRoster();
        }
        if (!rosterEverGot && (curPhase === "aircraft" || curPhase === "freefly" || curPhase === "landed")) {
            // get the roster for the first time, if player already in a game
            getRoster();
        }
        if (curPhase === "aircraft") {
            // start a new timer for calculating flight speed
            fpStartTime = undefined;
            fpEndTime   = undefined;
            // one more time in 5 seconds, just in case there were last second additions
            setTimeout(getRoster, 5000);
            // don't keep polling for the roster
            clearInterval(rosterInterval);
        }
        if (curPhase === "freefly") {
            prepareAutoPlane();
        }
        if (curPhase === "freefly" || curPhase === "landed") {
            // initiate sims (if it hasnt been done yet)
            if (sims.length===0) {
                simsNeedBuilding = true;
            }
        }
    }

    function onLobby() {
        // clear pretty much every kind of state info

        // simulation data
        sims = [];
        curEdge = Array(64).fill(0);
        curEdgeMax = 0;

        // HTML roster
        $("#roster").empty();

        // 'camera' location
        defaultViewBox();

        // flightpath info
        curFlightPath  = undefined;
        calcFlightPath = undefined;
        calcLandingLines = undefined;
        prevCalcFlightPath = undefined;
        prevCalcLandingLines = undefined;
        animateFlightPath = false;

        // auto plane info
        curPlanePosX = 0;
        curPlanePosY = 0;
        curPlaneDirection = 0;
        curPlaneSpeed = 0;

        // player locations
        curPosX = 0;
        curPosY = 0;
        prevPosX = 0;
        prevPosY = 0;
        prevTeamLocs = [];
        curTeamData = [];

        // player's in-game stats
        curDamageDealt = 0;
        curKills = 0;
        curHeadshots = 0;
        curMaxKillDist = 0;

        // squad's in-game stats
        curSquadInfo = [];

        // inventory
        curInvRaw = "";
        curInv = buildEmptyInventory();

        // roster
        curRoster = [];
        curAlives = "";

        // zones
        curWhite = undefined;
        curBlue  = undefined;
        curRed   = undefined;
        prevWhite = undefined;
        prevBlue  = undefined;
        prevRed   = undefined;
    }

    function isDead() {
        return (curPhase==="dead");
    }

    function listContains(item, list) {
        return list.indexOf(item)!==-1;
    }

    function notContains(item, list) {
        return list.indexOf(item)===-1;
    }

    // whether to draw various things in various phases
    function drawLocationsForPhase(phase) {
        return notContains(phase, ["lobby", "loading_screen", "airfield"]);
    }

    function drawFlightPathForPhase(phase) {
        return listContains(phase, ["aircraft", "freefly", "landed", "dead"]);
    }

    function drawLandingLinesForPhase(phase) {
        if (phase==="landed") return true;
        return listContains(phase, ["aircraft", "freefly"]);
    }

    function drawModeForPhase(phase) {
        return listContains(phase, ["aircraft", "freefly", "landed", "dead"]);
    }

    function drawZonesForPhase(phase) {
        return listContains(phase, ["aircraft", "freefly", "landed", "dead"]);
    }

    function phaseIsDead(phase) {
        if (phase==="landed") return false;
        if (phase==="freefly") return false;
        if (phase==="aircraft") return false;
        return true;
    }

    // turn a phase into something presentable
    function nicePhase() {
        if (curPhase === "lobby")          return "Lobby";
        if (curPhase === "loading_screen") return "Loading Screen";
        if (curPhase === "airfield")       return "Pre-game";
        if (curPhase === "aircraft")       return "Aircraft";
        if (curPhase === "freefly")        return "Freefly";
        if (curPhase === "landed")         return "Surviving";
        if (curPhase === "dead")           return "Dead";
        return curPhase;
    }


    // MODE
    function updateMode(mode) {
        if (isBlank(mode)) return;
        curMode = mode;
    }

    // turn a mode into something presentable
    function niceMode() {
        if (curMode === "solo")  return "Solos";
        if (curMode === "duo")   return "Duos";
        if (curMode === "squad") return "Squads";
        return "Unknown";
    }


/*
    ##     ##    ###    ########
    ###   ###   ## ##   ##     ##
    #### ####  ##   ##  ##     ##
    ## ### ## ##     ## ########
    ##     ## ######### ##
    ##     ## ##     ## ##
    ##     ## ##     ## ##
*/

    function updateMap(map) {
        if (isBlank(map)) return;
        curMap = map;

        console.log("Changing map to " + curMap);

        curMapSize = map_size(curMap);
        drawMapLoading();
        img_loader.src = "";
        img.src = "maps/getmap.php?map="+curMap+"&size="+canvas.scrollWidth;
        img_heat_loaded = false;
        img_heat.src = "maps/heat/"+curMap+"-heat-200.png";

        recalculateViewBox();

        sims = [];
    }

    function map_size(mapname) {
        if (mapname == "sanhok")  return 4080;
        if (mapname == "vikendi") return 6120;
        else return 8160;
    }

    // setInterval(function(){
    //     var mapID = Math.floor(Math.random()*5);
    //     if (mapID===0) img_loader.src = "maps/getmap.php?map=sanhok&size="+canvas.scrollWidth;
    //     if (mapID===1) img_loader.src = "maps/getmap.php?map=erangel&size="+canvas.scrollWidth;
    //     if (mapID===2) img_loader.src = "maps/getmap.php?map=vikendi&size="+canvas.scrollWidth;
    //     if (mapID===3) img_loader.src = "maps/getmap.php?map=miramar&size="+canvas.scrollWidth;
    // }, 3000);

    // function map_to_canvas(x, y) {
    //     return (ord * canvas.scrollWidth)/curMapSize;
    // }

    // function canvas_to_map(ord) {
    //     return (ord * curMapSize)/canvas.scrollWidth;
    // }


/*
    ##        #######   ######     ###    ######## ####  #######  ##    ##  ######
    ##       ##     ## ##    ##   ## ##      ##     ##  ##     ## ###   ## ##    ##
    ##       ##     ## ##        ##   ##     ##     ##  ##     ## ####  ## ##
    ##       ##     ## ##       ##     ##    ##     ##  ##     ## ## ## ##  ######
    ##       ##     ## ##       #########    ##     ##  ##     ## ##  ####       ##
    ##       ##     ## ##    ## ##     ##    ##     ##  ##     ## ##   ### ##    ##
    ########  #######   ######  ##     ##    ##    ####  #######  ##    ##  ######
*/

    function updateMyLocation(x, y) {
        prevPosX = curPosX;
        prevPosY = curPosY;
        curPosX = x;
        curPosY = y;
    }

    function rememberPrevTeamLocations() {
        for (var mateName in curTeamData) {
            var mate = curTeamData[mateName];
            prevTeamLocs[mateName] = {x:mate.x, y:mate.y};
        }
    }

/*
     ######  ########    ###    ########  ######
    ##    ##    ##      ## ##      ##    ##    ##
    ##          ##     ##   ##     ##    ##
     ######     ##    ##     ##    ##     ######
          ##    ##    #########    ##          ##
    ##    ##    ##    ##     ##    ##    ##    ##
     ######     ##    ##     ##    ##     ######
*/

    function updateKills(kills) {
        if (isBlank(kills)) return;
        curKills = kills;
        $("#kills").text(curKills);
    }

    function updateHeadshots(headshots) {
        if (isBlank(headshots)) return;
        curHeadshots = headshots;
        $("#headshots").text(curHeadshots);
    }

    function updateDamageDealt(damagedealt) {
        if (isBlank(damagedealt)) return;
        curDamageDealt = Math.round(damagedealt);
        $("#damagedealt").text(curDamageDealt);
    }

    function updateMaxKillDist(maxkilldist) {
        if (isBlank(maxkilldist)) return;
        curMaxKillDist = Math.round(maxkilldist)/100;
        $("#maxkilldist").text(curMaxKillDist);
    }




/*
    ######## ##       ####  ######   ##     ## ######## ########     ###    ######## ##     ##
    ##       ##        ##  ##    ##  ##     ##    ##    ##     ##   ## ##      ##    ##     ##
    ##       ##        ##  ##        ##     ##    ##    ##     ##  ##   ##     ##    ##     ##
    ######   ##        ##  ##   #### #########    ##    ########  ##     ##    ##    #########
    ##       ##        ##  ##    ##  ##     ##    ##    ##        #########    ##    ##     ##
    ##       ##        ##  ##    ##  ##     ##    ##    ##        ##     ##    ##    ##     ##
    ##       ######## ####  ######   ##     ##    ##    ##        ##     ##    ##    ##     ##
*/

    var fpA = null;    
    var fpB = null;
    var fpStartTime = undefined;
    var fpEndTime   = undefined;
    var fpStartPosX = 0;
    var fpStartPosY = 0;
    var fpEndPosX   = 0;
    var fpEndPosY   = 0;
    function updateFlightPath(fpath) {
        if (overridingFP) return;
        fpB = fpA;
        fpA = fpath;
        if (fpA!==fpB) {
            // console.log("new flight path:", fpA);
        }
        if (notBlank(fpath)) {
            if (isString(fpath.start)) {
                fpath.start = JSON.parse(fpath.start);
                fpath.start.x = parseFloat(fpath.start.x);
                fpath.start.y = parseFloat(fpath.start.y);
                fpath.end   = JSON.parse(fpath.end);
                fpath.end.x = parseFloat(fpath.end.x);
                fpath.end.y = parseFloat(fpath.end.y);
            }
            if (fpStartTime===undefined) {
                fpStartTime = new Date();
                fpStartPosX = curPosX;
                fpStartPosY = curPosY;
            } else {
                fpEndTime = new Date();
                fpEndPosX = curPosX;
                fpEndPosY = curPosY;
            }
            curFlightPath = fpath;
            curPlaneDirection = Math.atan2(fpath.end.y-fpath.start.y,fpath.end.x-fpath.start.x);
            recalculateFlightPath(curFlightPath);
            animateFlightPath = checkForAnimateFlightPath();
        }
    }

    function recalculateFlightPath(fp) {
        // record previous lines
        prevCalcFlightPath = calcFlightPath;
        prevCalcLandingLines = calcLandingLines;

        fp.start.x = parseFloat(fp.start.x);
        fp.start.y = parseFloat(fp.start.y);
        fp.end.x = parseFloat(fp.end.x);
        fp.end.y = parseFloat(fp.end.y);
        calcFlightPath = extendLineToBounds(fp);

        // the angle of the flight path and the angle perpendicular to it
        var angle = Math.atan2(fp.end.y - fp.start.y, fp.end.x - fp.start.x);
        var perpAngle = angle + (Math.PI / 2);

        var close1 = offsetLine(fp.start, fp.end,  1400, perpAngle);
        var close2 = offsetLine(fp.start, fp.end, -1400, perpAngle);
        var far1   = offsetLine(fp.start, fp.end,  2000, perpAngle);
        var far2   = offsetLine(fp.start, fp.end, -2000, perpAngle);

        close1 = extendLineToBounds(close1);
        close2 = extendLineToBounds(close2);
        far1   = extendLineToBounds(far1);
        far2   = extendLineToBounds(far2);
        
        calcLandingLines = [close1, close2, far1, far2];
        if (prevCalcLandingLines===undefined) prevCalcLandingLines = calcLandingLines;
    }

    function offsetLine(start, end, dist, angle) {
        return ({
            start: {
                x: start.x + dist*Math.cos(angle),
                y: start.y + dist*Math.sin(angle)
            },
            end: {
                x: end.x + dist*Math.cos(angle),
                y: end.y + dist*Math.sin(angle)
            }
        });
    }

    function differentFP(a, b) {
        if (a && b && a.start && a.end && b.start && b.end) {
            if (a.start.x !== b.start.x) return true;
            if (a.start.y !== b.start.y) return true;
            if (a.end.x !== a.end.y) return true;
            if (a.end.y !== b.end.y) return true;
            return false;
        }
        return true;
    }

    function extendLineToBounds(path) {
        var startX = path.start.x;
        var startY = path.start.y;
        var endX = path.end.x;
        var endY = path.end.y;

        var mSize = curMapSize;

        var offX = endX - startX;
        var offY = endY - startY;

        var dx = offX < 0 ? 0 : mSize;
        var dy = offY < 0 ? 0 : mSize;
        var py = dy;

        var sx = offX > 0 ? 0 : mSize;
        var sy = offY > 0 ? 0 : mSize;
        var ty = sy;

        if (offX === 0) {
            return {
            start: { x:startX, y:endY>startY ? 0 : mSize },
            end:   { x:startX, y:endY>startY ? mSize : 0 }
            }
        } else if (offY === 0) {
            return {
            start: { x:endX>startX ? 0 : mSize, y:startY },
            end:   { x:endX>startX ? mSize : 0, y:startY }
            }
        } else {
            dy = startY + (offY / offX) * (dx - startX);
            if (dy < 0 || dy > mSize) {
            dx = startX + (offX / offY) * (py - startY);
            dy = py;
            }

            sy = endY + (offY / offX) * (sx - endX);
            if (sy < 0 || sy > mSize) {
            sx = startX + (offX / offY) * (ty - startY);
            sy = ty;
            }
        }
        return {start: {x:sx, y:sy}, end: {x:dx, y:dy}}
    }

    function checkForAnimateFlightPath() {
        // console.log("checking");
        // console.log(isBlank(calcFlightPath));
        // console.log(isBlank(prevCalcFlightPath));
        if (isBlank(calcFlightPath) || isBlank(prevCalcFlightPath)) return false;
        if (curPhase=="aircraft") return true;
        return false;
    }


/*
    #### ##    ## ##     ## ######## ##    ## ########  #######  ########  ##    ##
     ##  ###   ## ##     ## ##       ###   ##    ##    ##     ## ##     ##  ##  ##
     ##  ####  ## ##     ## ##       ####  ##    ##    ##     ## ##     ##   ####
     ##  ## ## ## ##     ## ######   ## ## ##    ##    ##     ## ########     ##
     ##  ##  ####  ##   ##  ##       ##  ####    ##    ##     ## ##   ##      ##
     ##  ##   ###   ## ##   ##       ##   ###    ##    ##     ## ##    ##     ##
    #### ##    ##    ###    ######## ##    ##    ##     #######  ##     ##    ##
*/
    // the filenames of weapons, sorted by
    // close to long range
    var mainWepList = [
        "Item_Weapon_Berreta686_C",   // 1
        "Item_Weapon_Winchester_C",   // 2
        "Item_Weapon_Saiga12_C",      // 3
        "Item_Weapon_DP12_C",         // 4
        "Item_Weapon_UZI_C",          // 5
        "Item_Weapon_Thompson_C",     // 6
        "Item_Weapon_Vector_C",       // 7
        "Item_Weapon_BizonPP19_C",    // 8
        "Item_Weapon_UMP_C",          // 9
        "Item_Weapon_Groza_C",        // 10
        "Item_Weapon_M249_C",         // 11
        "Item_Weapon_AK47_C",         // 12
        "Item_Weapon_BerylM762_C",    // 13
        "Item_Weapon_DP28_C",         // 14
        "Item_Weapon_AUG_C",          // 15
        "Item_Weapon_MP5K_C",         // 16
        "Item_Weapon_SCAR-L_C",       // 17
        "Item_Weapon_QBZ95_C",        // 18
        "Item_Weapon_HK416_C",        // 19
        "Item_Weapon_G36C_C",         // 20
        "Item_Weapon_Mk47Mutant_C",   // 21
        "Item_Weapon_M16A4_C",        // 22
        "Item_Weapon_Win1894_C",      // 23
        "Item_Weapon_Mk14_C",         // 24
        "Item_Weapon_QBU88_C",        // 25
        "Item_Weapon_Mini14_C",       // 26
        "Item_Weapon_VSS_C",          // 27
        "Item_Weapon_SKS_C",          // 28
        "Item_Weapon_FNFal_C",        // 29
        "Item_Weapon_Crossbow_C",     // 30
        "Item_Weapon_Kar98k_C",       // 31
        "Item_Weapon_M24_C",          // 32
        "Item_Weapon_AWM_C"           // 33
    ];

    function weaponNameFromNumber(ind) {
        if (ind <= mainWepList.length && ind > 0)
            return mainWepList[ind-1];
        return "none";
    }

    var blank_image_base64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";

    function setHelmet(id) {
        curInv.helmet = id;
        $("#img_helmet_me").attr("src", "img/inv/helmet_"+id+".png");
    }
    
    function setVest(id) {
        curInv.vest = id;
        $("#img_vest_me").attr("src", "img/inv/vest_"+id+".png");
    }

    function setBag(id) {
        curInv.bag = id;
        $("#img_bag_me").attr("src", "img/inv/bag_"+id+".png");
    }

    function setGhillie(id) {
        curInv.ghillie = id;
        if (id>0)
            $("#img_ghillie_me").attr("src", "img/inv/ghillie_"+id+".png");
        else
            $("#img_ghillie_me").attr("src", blank_image_base64);
    }

    function setWeapons(id1, id2, contID = "#mystats") {
        curInv.wepClose = id1;
        curInv.wepRange = id2;

        var wpndiv = $(contID).find("#weapons");
        var wpnA = weaponNameFromNumber(id1);
        var wpnB = weaponNameFromNumber(id2);

        // set the appropriate images
        if (wpnA!=="none")
            wpndiv.find("#wpnA").find("img.wpnimg").attr("src", "img/wpn/"+wpnA+".png");
        else
            wpndiv.find("#wpnA").find("img.wpnimg").attr("src", "");
            // wpndiv.find("#wpnA").find("img.wpnimg").attr("src", blank_image_base64);

        if (wpnB!=="none")
            wpndiv.find("#wpnB").find("img.wpnimg").attr("src", "img/wpn/"+wpnB+".png");
        else
            wpndiv.find("#wpnB").find("img.wpnimg").attr("src", "");
            // wpndiv.find("#wpnB").find("img.wpnimg").attr("src", blank_image_base64);
    }

    function updateTeammateInventory(name, inv) {
        if (isBlank(inv)) return;
        var contID = "#stats_"+name;
        var [helmet, vest, bag, ghillie, // gear
                wepClose, wepRange,         // weapons
                medKits, firstAids, bandages, adrenalines, painKillers, energies // meds
                ] = inv.split(",");
        $(contID).find("#img_helmet").attr("src", "img/inv/helmet_"+helmet+".png");
        $(contID).find("#img_vest").attr("src", "img/inv/vest_"+vest+".png");
        $(contID).find("#img_bag").attr("src", "img/inv/bag_"+bag+".png");
        setWeapons(wepClose, wepRange, contID);
        setMeds(medKits, firstAids, bandages, adrenalines, painKillers, energies, contID);
        $(contID).find("#playercontent").slideDown(1000);
    }

    function updateInv(inv) {
        curInvRaw = inv;
        // get data
        if (isBlank(inv)) return false;
        var [helmet, vest, bag, ghillie, // gear
                wepClose, wepRange,         // weapons
                medKits, firstAids, bandages, adrenalines, painKillers, energies // meds
                ] = inv.split(",");

        // check for changes
        if (helmet!==curInv.helmet)   setHelmet(helmet);
        if (vest!==curInv.vest)       setVest(vest);
        if (bag!==curInv.bag)         setBag(bag);
        if (ghillie!==curInv.ghillie) setGhillie(ghillie);
        if (wepClose!==curInv.wepClose || wepRange!==curInv.wepRange)
            setWeapons(wepClose, wepRange);
        
        // meds
        setMeds(medKits, firstAids, bandages, adrenalines, painKillers, energies);
    }

    jQuery.fn.isEmpty  = function(){ return !this.length  };
    jQuery.fn.notEmpty = function(){ return !!this.length };

    function invShowHide(show, name, src, cont) {
        if (show && cont.find("#"+name).isEmpty()) {
            cont.append($("<img>").attr("id", name).attr("src", src));
        } else if (!show) {
            cont.find("#"+name).remove();
        }
    }

    function setMeds(medKits, firstAids, bandages, adrenalines, painKillers, energies, contID = "#mystats") {
        // parse inputs
        [medKits, firstAids, bandages, adrenalines, painKillers, energies]
        = [medKits, firstAids, bandages, adrenalines, painKillers, energies]
        .map((s) => (parseInt(s)>0));

        var cont = $(contID).find("#inventory");
        invShowHide(medKits,     "medkit",     "img/med/medkit.png",     cont);
        invShowHide(firstAids,   "firstaid",   "img/med/firstaid.png",   cont);
        invShowHide(bandages,    "bandage",    "img/med/bandage.png",    cont);
        invShowHide(adrenalines, "adrenaline", "img/med/adrenaline.png", cont);
        invShowHide(painKillers, "painkiller", "img/med/painkiller.png", cont);
        invShowHide(energies,    "energy",     "img/med/energy.png",     cont);            
    }

    function buildEmptyInventory() {
        inv = {};
        inv.helmet = inv.bag = inv.vest = 0;
        inv.wepClose = inv.wepRange = 0;
        return inv;
    }


/*
    ########  #######  ##    ## ########  ######
         ##  ##     ## ###   ## ##       ##    ##
        ##   ##     ## ####  ## ##       ##
       ##    ##     ## ## ## ## ######    ######
      ##     ##     ## ##  #### ##             ##
     ##      ##     ## ##   ### ##       ##    ##
    ########  #######  ##    ## ########  ######
*/
    function updateWhiteZone(zone) {
        prevWhite = curWhite;
        curWhite = zone;
        if (isBlank(prevWhite))
            prevWhite = getOuterZone();

        // load a new image of higher resolution to account for
        // a smaller view window, if the new circle is different.
        if (curWhite !== prevWhite) {
            updateRenderMapSize();
            if (debug_runsim) moveSimsToWhite();
        }
    }
    function updateBlueZone(zone) {
        prevBlue = curBlue;
        curBlue = zone;
        if (isBlank(prevBlue))
            prevBlue = getOuterZone();
    }
    function updateRedZone(zone) {
        prevRed = curRed;
        curRed = zone;
    }
    function getOuterZone() {
        var mapsz = curMapSize;
        var mid = mapsz/2;
        var rad = mapsz*0.75;
        return '{"x":'+mid+', "y":'+mid+', "radius":'+rad+'}';
    }



/*
        ########   #######   ######  ######## ######## ########
        ##     ## ##     ## ##    ##    ##    ##       ##     ##
        ##     ## ##     ## ##          ##    ##       ##     ##
        ########  ##     ##  ######     ##    ######   ########
        ##   ##   ##     ##       ##    ##    ##       ##   ##
        ##    ##  ##     ## ##    ##    ##    ##       ##    ##
        ##     ##  #######   ######     ##    ######## ##     ##
*/

    // get the roster from the server
    function getRoster() {
        rosterEverGot = true;
        jQuery.getJSON("api/getroster.php?name="+myName)
        .done(function(data) {
            if (data.roster) processRoster(data.roster);
        });
    }

    // process roster info
    function processRoster(roster) {
        if (typeof roster === "string" && roster.length > 10) {
            curRoster = [];
            for (var i=0; i<99; i++) {
                curRoster[i] = undefined;
            }
            var list = roster.split(',');
            for (var i=0; i<list.length; i++) {
                curRoster[i] = list[i];
            }
        }
        showRoster();
    }

    // update who is alive on the roster list on the page
    function updateAlives(alives) {
        if (isBlank(alives)) return;
        if (!alives.length) return;
        curAlives = alives;
        var enemyCount = 0;
        for (var i=0; i<alives.length; i++) {
            if (curRoster[i] && curRoster[i].length > 0) {
                if (alives.charAt(i) === "1") {
                    enemyCount++;
                } else {
                    curRoster[i] = undefined;
                    $("#roster_"+i).slideUp();
                }
            }
        }
        if (enemyCount > 1) {
            $("#roster_header").text(enemyCount + " enemies:");
        } else if (enemyCount === 1) {
            $("#roster_header").text("1 enemy:");
        }
    }

    // show the roster on the page
    function showRoster() {
        if (isBlank(curRoster)) return;

        // get a list of indexes of a sorted curRoster. (argsort).
        // items will display in alphabetical order, but their indexes won't change.
        var indexes = [];
        for (var i=0; i<curRoster.length; i++)
            indexes[i] = i;

        indexes.sort(function(a, b) {
            if (curRoster[a] && curRoster[b])
                return alphasort(curRoster[a], curRoster[b]);
            else return 0;
        });

        // empty the roster
        var col = $("#roster");
        col.empty();

        var enemyCount = 0;

        // add all names in divs to the roster div
        for (var i=0; i<curRoster.length; i++) {
            var ind = indexes[i];
            var name = curRoster[ind];
            var isEnemy = true;
            if (name === myName) isEnemy = false;
            for (var t=0; t<curSquad.length; t++) {
                if (name === curSquad[t])
                    isEnemy = false;
            }
            if (isEnemy && name && name.length > 0) {
                $('<div>', {id: "roster_"+ind}).text(name).appendTo(col);
                enemyCount++;
            } else {
                $('<div>', {id: "roster_"+ind, class:"rosterblank"}).appendTo(col);
            }
        }

        if (enemyCount>1) {
            $('<div>', {id:"roster_header"}).text(enemyCount + " enemies:").prependTo(col);
        } else if (enemyCount===1) {
            $('<div>', {id:"roster_header"}).text("1 enemy:").prependTo(col);
        }
    }



/*
    ########   #######  ##       ##       #### ##    ##  ######
    ##     ## ##     ## ##       ##        ##  ###   ## ##    ##
    ##     ## ##     ## ##       ##        ##  ####  ## ##
    ########  ##     ## ##       ##        ##  ## ## ## ##   ####
    ##        ##     ## ##       ##        ##  ##  #### ##    ##
    ##        ##     ## ##       ##        ##  ##   ### ##    ##
    ##         #######  ######## ######## #### ##    ##  ######
*/

    function reAssociate(key, numArray) {
        var assocArray = [];
        for (var i=0; i<numArray.length; i++) {
            assocArray[numArray[i][key]] = numArray[i];
        }
        return assocArray;
    }

    var cancelPoll = false;
    function poll(pollingCallback) {
        if (cancelPoll) return;
        jQuery.getJSON("api/poll.php?name="+myName)
        .done(function(data) {
            if (isBlank(data.me.x) || isBlank(data.me.map) || data.me.map==="unknown") {
                // we aren't getting location info on the poll response, so the player
                // must not exist in the tables. This means their app has never run or seen
                // their name yet (aircraft on first game). display a message to this effect.
                drawNoInfo();
                return;
            }

            // update zones
            updateWhiteZone(data.me.white);
            updateBlueZone(data.me.blue);
            updateRedZone(data.me.red);

            // update map/phase/mode
            if (data.me.map !== curMap)
                updateMap(data.me.map);
            if (data.me.phase !== curPhase)
                updatePhase(data.me.phase);
            if (data.me.mode !== curMode)
                updateMode(data.me.mode);
            
            // // sort the locations by name, for display consistency
            // var sortFun = function(loc1, loc2){
            //     if (loc1.name === myName) return -1;
            //     if (loc2.name === myName) return  1;
            //     return alphasort(loc1.name, loc2.name);
            // };

            updateMyLocation(data.me.x, data.me.y);
            rememberPrevTeamLocations();

            // get the info about other players that we get even if they
            // don't have the app. their data will be overridden if they
            // do have the app running.

            var teamData = [];
            if (data.me.teamdata) {
                teamData = reAssociate("name", JSON.parse(data.me.teamdata));
            }

            // go through the data from users with the app, overwrite data, and
            // write extra data to the displays.
            for (var i=0; i<data.squadinfo.length; i++) {
                var mate = data.squadinfo[i];
                var mateName = mate.teammate;
                if (teamData[mateName]===undefined)
                    teamData[mateName] = {name:mateName};
                teamData[mateName].x = mate.x;
                teamData[mateName].y = mate.y;
                teamData[mateName].alive = !phaseIsDead(mate.phase);
            }
            curTeamData = teamData;




            // var checkDead = function(name) {
            //     for (var i=0; i<data.squadinfo.length; i++) {
            //         if (data.squadinfo[i].name === name)
            //             return phaseIsDead(data.squadinfo[i].phase);
            //     }
            //     return false;
            // };

            // var alllocs = [];
            // if (data.me.teamloc) {
            //     // if we have a "teamloc" entry, then we know our position and our
            //     // teammates positions. Also try to find out from squadinfo
            //     // if the player is dead (only if they have the app running).
            //     var teamloc = JSON.parse(data.me.teamloc);
            //     for (var i=0; i<teamloc.length; i++) {
            //         alllocs.push({
            //             'name': teamloc[i].player,
            //             'x'   : teamloc[i].location.x,
            //             'y'   : teamloc[i].location.y,
            //             'dead': checkDead(teamloc[i].player)
            //         });
            //     }
            // } else {
            //     // if not, collate position information from all squadmates
            //     // who have recently updated their position on the server.
            //     // this will also grab whether they are dead. first, add your
            //     // own data to the list
            //     alllocs.push({
            //         'name': myName,
            //         'x'   : data.me.x,
            //         'y'   : data.me.y,
            //         'dead': phaseIsDead(data.me.phase)
            //     });
            //     // now the data for your squadmates
            //     for (var i=0; i<data.squadinfo.length; i++) {
            //         alllocs.push({
            //             'name': data.squadinfo[i].player,
            //             'x'   : data.squadinfo[i].x,
            //             'y'   : data.squadinfo[i].y,
            //             'dead': (phaseIsDead(data.squadinfo[i].phase))
            //         });
            //     }
            // }
            // // sort locations by name, so order is consistent (and you are drawn on top)
            // alllocs.sort(sortFun);

            // record the new player locations
            // updateLocations(alllocs);

            // check if the squad has changed
            data.squad.sort(alphasort);
            if (diffSquad(curSquad, data.squad))
                updateSquad(data.squad);

            // update the squad info
            updateSquadInfo(data.squadinfo);

            // we might not recalculate the flight path, so
            // make sure we don't accidentally animate it
            animateFlightPath = false;

            // process lots of other info
            if (data.me.alives !== curAlives)
                updateAlives(data.me.alives);
            if (data.me.inv !== curInvRaw)
                updateInv(data.me.inv);
            if (differentFP(data.me.flightpath, curFlightPath))
                updateFlightPath(data.me.flightpath);
            if (data.me.damagedealt !== curDamageDealt)
                updateDamageDealt(data.me.damagedealt);
            if (data.me.kills !== curKills)
                updateKills(data.me.kills);
            if (data.me.headshots !== curHeadshots)
                updateHeadshots(data.me.headshots);
            if (data.me.maxkilldist !== curMaxKillDist)
                updateMaxKillDist(data.me.maxkilldist);
            
            // recalculate the view box
            recalculateViewBox();

            // build the sims (if necessary)
            if (simsNeedBuilding && debug_runsim) {
                if (img_heat_loaded) {
                    console.log("Placing sims on the map.");
                    initialiseHeatmapSims();
                } else {
                    console.log("Waiting for heatmap to load...");
                }
            }

            // redraw the map
            initiateRedraw();

        })
        .always(pollingCallback);
    }

    // call requestFn (which takes a callback parameter when it's finished asynchronously)
    // once every second, unless it takes longer than that for it to call its callback.
    function MaxOncePerSecond(requestFn){
        var timeoutHandle = 0;
        var beenOneSecond = false;
        var gotReturn = false;
        // do this when requestFn is finished
        function onReturn() {
            gotReturn = true;
            if (beenOneSecond === true) {
                // we got a return and it's been one second, so run again.
                schedulerun();
            }
        }
        // do this in one second
        function onOneSecond() {
            beenOneSecond = true;
            if (gotReturn === true) {
                // it's been one second and we've got a return, so run again.
                schedulerun();
            }
        }
        // run requestFn and set up for it to finish
        function schedulerun() {
            beenOneSecond = false;
            gotReturn = false;
            timeoutHandle = setTimeout(onOneSecond, 1000);
            requestFn(onReturn);
        }
        schedulerun(); // start the process

        return timeoutHandle;
    }
/*
    ##     ## ######## ##       ########  ######## ########   ######
    ##     ## ##       ##       ##     ## ##       ##     ## ##    ##
    ##     ## ##       ##       ##     ## ##       ##     ## ##
    ######### ######   ##       ########  ######   ########   ######
    ##     ## ##       ##       ##        ##       ##   ##         ##
    ##     ## ##       ##       ##        ##       ##    ##  ##    ##
    ##     ## ######## ######## ##        ######## ##     ##  ######
*/

    function getBetween(start, end, percent) {
        start = parseInt(start);
        end = parseInt(end);
        var diff = end - start;
        var result = start + (percent * diff);
        return result;
    }

    function notBlank(a) {
        if (a===undefined) return false;
        if (a===null) return false;
        if (a==="") return false;
        return true;
    }

    function isBlank(a) {
        return !notBlank(a);
    }

    function isString(v) {
        return (typeof v === 'string' || v instanceof String);
    }

/*
       ###    ##       ####  ######   ##    ## ##     ## ######## ##    ## ########
      ## ##   ##        ##  ##    ##  ###   ## ###   ### ##       ###   ##    ##
     ##   ##  ##        ##  ##        ####  ## #### #### ##       ####  ##    ##
    ##     ## ##        ##  ##   #### ## ## ## ## ### ## ######   ## ## ##    ##
    ######### ##        ##  ##    ##  ##  #### ##     ## ##       ##  ####    ##
    ##     ## ##        ##  ##    ##  ##   ### ##     ## ##       ##   ###    ##
    ##     ## ######## ####  ######   ##    ## ##     ## ######## ##    ##    ##
*/

    function rightAlign() {
        // remove the "left" class from the main table
        $("#maintable").removeClass("left");
        // toggle behaviour
        $("#mapcanvas").off('dblclick').on('dblclick', leftAlign);
        // save the preference
        localStorage.setItem('screenAlignment', 'right');
    }
    function leftAlign() {
         // add the "left" class to the main table
        $("#maintable").removeClass("left").addClass("left");
        // toggle behaviour
        $("#mapcanvas").off('dblclick').on('dblclick', rightAlign);
        // save the preference
        localStorage.setItem('screenAlignment', 'left');
    }

    function getSavedAlignment() {
        if (localStorage.getItem('screenAlignment') === 'left') {
            leftAlign();
        } else {
            rightAlign();
        }
    }

/*
    #### ##    ## #### ########
     ##  ###   ##  ##     ##
     ##  ####  ##  ##     ##
     ##  ## ## ##  ##     ##
     ##  ##  ####  ##     ##
     ##  ##   ###  ##     ##
    #### ##    ## ####    ##
*/
    function initApp() {
        recalculateViewBox();
        MaxOncePerSecond(poll);
    }

    $(function() {
        // write the user's name to the name field
        $("#myName").text(myName);

        // check if the alignment should change on load
        getSavedAlignment();

        // start polling
        initApp();
    });

    // get the player's name from the URL
    function getUrlPlayerName() {
        var search = window.location.search.substring(1);
        return search.split("&")[0];
    }

    </script>
  </body>
</html>